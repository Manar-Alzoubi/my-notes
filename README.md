# my-notes 
##  I cant download ubunto until now because a few problems in my laptop , so i will write a description here:
## My name is Manar Alzoubi ,I am 33 years old ,my studing is Masters of computer science and I graduated from Yarmouk university 

## To avoid some issues that faced programmers and makes a long-term damage and increases by time you should improve mindest of developer, some key points to make are:
<ol>
<li>Conceiving the purpose of software</li>
  understand the ppurpose of software not to show off how intelligent you are, but to write good software that helps people.
<li>The Goals of Software Design</li>
  the software must be created easily, makes less time to write, mamintained and be helpful>
<li>(Mis)understanding</li>
  Understanding is the key difference between a bad developer and a good developer. 
 <li>Simplicity</li>
  A good developer creates things that are easy to understand so that it’s really easy to shake out all the bugs,most of the programming failures happen because of that mentality
<li>Complexity</li>
  when the programmer increases the comlixity then the time needed will increase, then make unnecessary code, so remember Your main purpose is to control complexity, not to create it.
<li>Maintenance</li>
   ignorance of future code maintenance is a big mistake, the effort of maintenance is proportional to the complexity of the software.
  <li>Consistency</li>
  f you do something one way in one place, do it that way in every place,if you name a variable thisIsVariable, then all of your variables should be named that way
<li>Prioritizing</li>
  there are three important factors that will help you make a better decision:
  <ul>
<li>The desirability of a change (D): How much do you want that change to happen?</li>
<li>The value of a change (V): How much value does the change offer? How much does it help your users?</li>
<li>The effort required to perform the change (E): How much work will you need to do to accomplish this change?</li>
</ul>
  The equation is simple: D=V/E
  The changes that will bring you a lot of value and require little effort are better than those that will bring little value and require a lot of effort
<li>Solving Problems</li>
  Think before acting,and make steps to solve your problem.
 <li>Good enough is fine</li>
  focus on the problem will solve and how  software will help people, Start small, improve it, then extend.

  <li>Predictions</li>
  Being too generic involves a lot of code that isn’t needed
<li>Assumptions</li>
  an assumption can kill a software project, implement a program to solve the problem now and in the future make changes.
 <li>Stop Reinventing</li>
  Don’t reinvent the wheel
  <li>Resistance</li>
  always Go back and remember your software purpose. Then remember the simple equation in prioritizing section
  <li> Automation</li>
  If you can automate it, automate it, don’t spend your time on repetitive tasks
<li>Code measurement</li>
  The optimum code is a small bunch of code that is easy to understand, easy to read
<li>Productivity</li>
  Your main goal should be keeping your code base as small as possible
 <li>Testing</li>
  You should be reliable,that you committed new code to source control your code will be tested, and works.
  <li> (Under)Estimation</li>
  your code is tested, and works, everything takes longer than you think
<li>Running Away From Rewriting</li>
  Rewriting code is often a developer delusion, not the solution in most cases,Refactoring should be the first option
 <li>Documentation and Commenting</li>
  Write a comment to explain “WHY”, not to explain “WHAT”
   <li> Picking Technologies (Tools, Libraries, etc.)</li>
  Don’t depend on external technologies. But when you have to do so, try to reduce your dependency on them as much as you can
<li>Self-Development</li>
  Know that every specific problem has its own specific solution
 <li>Don’t be a hero</li>
  Don’t be obsessive. Know when to quit. Don’t hesitate to ask for help
  <li>Don’t Ask Questions… Ask For Help</li>
  When you can’t think of anything on your own, search! Find answers and try them out. Modify those answers, see if you can understand why they work, adapt them to your code.
</ol>
 
